---
import { Image } from "astro:assets";
import lWing from "../assets/L_Wing.svg";
import rWing from "../assets/R_Wing.svg";
import wishLogo from "../assets/WISHLOGO.svg";
import { Countdown } from "./additional/Countdown";
---

<div id="wings-scene" class="wings-scene">
  <div id="wings-sticky" class="wings-sticky">
    <!-- Left wing -->
    <img
      id="wing-l"
      src={lWing.src}
      alt=""
      class="wing wing-l pointer-events-none select-none"
      aria-hidden="true"
    />

    <!-- Right wing -->
    <img
      id="wing-r"
      src={rWing.src}
      alt=""
      class="wing wing-r pointer-events-none select-none"
      aria-hidden="true"
    />

    <!-- Welcome content — fades in as wings spread -->
    <div
      id="welcome-content"
      class="welcome-content relative z-10 flex flex-col items-center gap-6 px-4 pt-24 sm:gap-8 md:gap-10 md:pt-32 lg:gap-12"
    >
      <h1
        class="welcome-title text-center font-['Cinzel_Decorative'] leading-[1.4] font-normal tracking-tight text-white"
      >
        Make your biggest
        <Image
          src={wishLogo}
          alt="WISH"
          class="wish-logo-inline inline-block align-middle drop-shadow-[0px_0px_10px_rgba(119,22,208,0.9)]"
        />
        come true
      </h1>

      <Countdown client:only="react" />

      <a
        href="/registration"
        class="register-btn group relative overflow-hidden rounded-[7.5px_60px_7.5px_60px] p-[1.5px]"
      >
        <div
          class="absolute inset-0 rounded-[7.5px_60px_7.5px_60px] bg-gradient-to-tr from-white/80 to-transparent opacity-50"
        >
        </div>
        <div
          class="register-btn-inner relative flex items-center justify-center rounded-[7.5px_60px_7.5px_60px] bg-[radial-gradient(ellipse_at_center,rgba(0,0,0,0.5)_0%,#9A44E9_100%)] transition-transform duration-300 group-hover:scale-105"
        >
          <span class="register-btn-text font-['Cinzel'] text-white">
            Register
          </span>
        </div>
      </a>
    </div>
  </div>
</div>

<style>
  :root:not(.js) .wing,
  :root:not(.js) .welcome-content {
    opacity: 1 !important;
    transform: none !important;
  }

  .wings-scene {
    position: relative;
    height: 200dvh;
  }

  .wings-sticky {
    position: sticky;
    top: 0;
    height: 100dvh;
    overflow: hidden;
    display: flex;
    align-items: center;
    justify-content: center;
  }

  .wing {
    position: absolute;
    top: 50%;
    width: auto;
    height: clamp(200px, 60vh, 700px);
    opacity: 0;
    transition: none;
    will-change: transform, opacity;
  }

  .wing-l {
    left: 0;
  }
  .wing-r {
    right: 0;
  }

  .welcome-content {
    opacity: 0;
    transform: translateY(24px);
    will-change: opacity, transform;
    transition: none;
    z-index: 10;
  }

  @media (max-width: 767px) {
    .welcome-content {
      opacity: 1 !important;
      transform: none !important;
    }
    .wing {
      z-index: 0;
    }
  }

  /* ── Text / button sizing (unchanged from original) ── */
  .welcome-title {
    font-size: clamp(1rem, 2.5vw, 3rem);
    letter-spacing: -0.02em;
    text-shadow:
      0px 0px 4.5px rgba(255, 255, 255, 1),
      0px 0px 60px rgba(255, 255, 255, 0.8),
      0px 0px 75px rgba(255, 255, 255, 0.4);
  }

  .wish-logo-inline {
    height: 1.1em;
    width: auto;
    vertical-align: middle;
    margin: 0 0.1em;
  }

  .register-btn-inner {
    width: clamp(120px, 15vw, 300px);
    height: clamp(36px, 4vw, 80px);
    box-shadow: 0px 0px 20px 0px rgba(119, 22, 208, 0.4);
  }

  .register-btn-text {
    font-size: clamp(1rem, 2vw, 2.5rem);
    filter: drop-shadow(0px 0px 10px rgba(255, 255, 255, 0.6));
  }
</style>

<script>
  (function () {
    const scene = document.getElementById("wings-scene")!;
    const wingL = document.getElementById("wing-l") as HTMLImageElement;
    const wingR = document.getElementById("wing-r") as HTMLImageElement;
    const content = document.getElementById("welcome-content")!;

    if (!scene || !wingL || !wingR || !content) return;

    function easeInOutCubic(t: number): number {
      return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
    }
    function clamp(v: number, lo: number, hi: number): number {
      return Math.max(lo, Math.min(hi, v));
    }
    function lerp(a: number, b: number, t: number): number {
      return a + (b - a) * t;
    }

    let isMobileCache = false;
    let finalLx = "",
      finalRx = "",
      finalY = "-40%";
    let slideOffsetCache = 0;

    function updateBreakpointCache() {
      const w = window.innerWidth;
      isMobileCache = w < 768;
      const tablet = w >= 768 && w <= 1024;
      finalLx = isMobileCache ? "-30%" : tablet ? "-20%" : "15%";
      finalRx = isMobileCache ? "30%" : tablet ? "20%" : "-15%";
      slideOffsetCache = w * 0.6;
    }

    let startDxL = 0;
    let startDxR = 0;

    function measureCenterOffsets() {
      if (isMobileCache) return;
      const centerX = window.innerWidth / 2;
      const rL = wingL.getBoundingClientRect();
      const rR = wingR.getBoundingClientRect();
      startDxL = centerX - rL.right;
      startDxR = centerX - rR.left;
    }

    function applyProgress(rawProgress: number) {
      const p = easeInOutCubic(clamp(rawProgress, 0, 1));

      if (isMobileCache) {
        const extraL = lerp(-slideOffsetCache, 0, p);
        const extraR = lerp(slideOffsetCache, 0, p);
        wingL.style.transform = `translate(calc(${finalLx} + ${extraL}px), ${finalY})`;
        wingR.style.transform = `translate(calc(${finalRx} + ${extraR}px), ${finalY})`;
        wingL.style.opacity = String(p * 0.4);
        wingR.style.opacity = String(p * 0.4);
        content.style.opacity = "";
        content.style.transform = "";
      } else {
        const dxL = lerp(startDxL, 0, p);
        const dxR = lerp(startDxR, 0, p);
        wingL.style.transform = `translate(calc(${finalLx} + ${dxL}px), ${finalY})`;
        wingR.style.transform = `translate(calc(${finalRx} + ${dxR}px), ${finalY})`;
        wingL.style.opacity = "1";
        wingR.style.opacity = "1";
        const contentP = clamp((rawProgress - 0.4) / 0.5, 0, 1);
        const contentEased = easeInOutCubic(contentP);
        content.style.opacity = String(contentEased);
        content.style.transform = `translateY(${lerp(24, 0, contentEased)}px)`;
      }
    }

    function setWingHeight() {
      const tablet = window.innerWidth >= 768 && window.innerWidth <= 1024;
      const h = isMobileCache
        ? "45vh"
        : tablet
          ? "55vh"
          : "clamp(200px, 60vh, 700px)";
      wingL.style.height = h;
      wingR.style.height = h;
    }

    let rafId = 0;
    let lastProgress = -1;
    let scrollableHeight = 0;

    function init() {
      updateBreakpointCache();
      setWingHeight();
      scrollableHeight = scene.offsetHeight - window.innerHeight;

      wingL.style.opacity = "0";
      wingR.style.opacity = "0";
      wingL.style.transform = `translate(${finalLx}, ${finalY})`;
      wingR.style.transform = `translate(${finalRx}, ${finalY})`;
      void wingL.offsetWidth; // force layout

      measureCenterOffsets(); // skips on mobile (guarded inside)

      const scrollProgress = clamp(
        window.scrollY / Math.max(1, scrollableHeight),
        0,
        1,
      );
      applyProgress(scrollProgress);
    }

    function onScroll() {
      if (rafId) return;
      rafId = requestAnimationFrame(() => {
        rafId = 0;
        if (scrollableHeight <= 0) {
          applyProgress(1);
          return;
        }
        const progress = clamp(window.scrollY / scrollableHeight, 0, 1);
        if (Math.abs(progress - lastProgress) > 0.0005) {
          lastProgress = progress;
          applyProgress(progress);
        }
      });
    }

    function whenLoaded(cb: () => void) {
      const imgs = [wingL, wingR];
      const pending = imgs.filter((img) => !img.complete);
      if (pending.length === 0) {
        cb();
        return;
      }
      let count = pending.length;
      pending.forEach((img) => {
        img.addEventListener(
          "load",
          () => {
            if (--count === 0) cb();
          },
          { once: true },
        );
        img.addEventListener(
          "error",
          () => {
            if (--count === 0) cb();
          },
          { once: true },
        );
      });
    }

    whenLoaded(() => {
      init();
      window.addEventListener("scroll", onScroll, { passive: true });
      window.addEventListener(
        "resize",
        () => {
          updateBreakpointCache();
          scrollableHeight = scene.offsetHeight - window.innerHeight;
          setWingHeight();
          measureCenterOffsets(); // skips on mobile
          const p = clamp(window.scrollY / Math.max(1, scrollableHeight), 0, 1);
          applyProgress(p);
        },
        { passive: true },
      );
    });
  })();
</script>
